<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Karaoke Finder</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      min-height: 100vh;
      background: radial-gradient(circle at top, #111827, #0f172a);
      color: #f8fafc;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 32px 16px;
    }
    body.modal-open {
      overflow: hidden;
    }
    .app {
      width: min(100%, 900px);
      display: grid;
      gap: 18px;
    }
    .search-box {
      display: block;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 18px;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.35);
    }
    .search-box input {
      width: 100%;
      padding: 18px 20px;
      background: transparent;
      border: none;
      color: inherit;
      font-size: 1.05rem;
      outline: none;
    }
    .search-box input::placeholder { color: rgba(226, 232, 240, 0.5); }
    .status {
      margin: 0;
      padding: 0 8px 4px;
      min-height: 18px;
      font-size: 0.9rem;
      color: rgba(148, 191, 255, 0.85);
    }
    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(15, 23, 42, 0.75);
      backdrop-filter: blur(6px);
      z-index: 999;
      padding: clamp(16px, 4vw, 32px);
      transition: opacity 0.2s ease, visibility 0.2s ease;
    }
    .modal.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .modal-content {
      position: relative;
      width: min(100%, 900px);
      aspect-ratio: 16 / 9;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 20px;
      box-shadow: 0 32px 64px rgba(15, 23, 42, 0.55);
      overflow: hidden;
    }
    .modal iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: none;
    }
    .modal-placeholder {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      text-align: center;
      padding: 24px;
      color: rgba(226, 232, 240, 0.85);
      gap: 12px;
    }
    .modal-close {
      position: absolute;
      top: 14px;
      right: 14px;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.6);
      color: inherit;
      cursor: pointer;
      font-size: 1.2rem;
      display: grid;
      place-items: center;
      transition: transform 0.15s ease, background 0.2s ease;
    }
    .modal-close:hover,
    .modal-close:focus-visible {
      transform: scale(1.05);
      background: rgba(56, 189, 248, 0.2);
    }
    .results {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 8px;
    }
    .results button,
    .results li.empty {
      width: 100%;
      background: rgba(15, 23, 42, 0.7);
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 14px 18px;
      color: inherit;
      font-weight: 500;
      text-align: left;
      cursor: pointer;
      transition: transform 0.18s ease, border-color 0.18s ease, background 0.18s ease;
      outline: none;
    }
    .results button:hover,
    .results button:focus-visible {
      transform: translateY(-1px);
      border-color: rgba(56, 189, 248, 0.6);
      background: rgba(56, 189, 248, 0.12);
    }
    .results li.empty {
      text-align: center;
      opacity: 0.6;
      font-weight: 400;
      cursor: default;
    }
    @media (min-width: 640px) {
      body { padding: 48px 16px; }
    }
  </style>
</head>
<body>
  <div id="modal" class="modal hidden" role="dialog" aria-modal="true" aria-label="Tr√¨nh ph√°t karaoke">
    <div class="modal-content">
      <button id="modal-close" class="modal-close" type="button" aria-label="ƒê√≥ng tr√¨nh ph√°t">&times;</button>
      <div id="modal-placeholder" class="modal-placeholder">ƒêang chu·∫©n b·ªã video...</div>
      <iframe
        id="modal-frame"
        title="Karaoke Player"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
        allowfullscreen
      ></iframe>
    </div>
  </div>

  <main class="app">
    <label class="search-box">
      <input
        type="search"
        id="search"
        placeholder="Nh·∫≠p t√™n b√†i h√°t karaoke..."
        autocomplete="off"
        spellcheck="false"
      />
    </label>
    <p id="status" class="status" role="status" aria-live="polite"></p>
    <ul id="results" class="results"></ul>
  </main>

  <script>
    const songs = [
      { title: "Karaoke Em G√°i M∆∞a - H∆∞∆°ng Tr√†m", query: "karaoke em g√°i m∆∞a h∆∞∆°ng tr√†m" },
      { title: "Karaoke Ng∆∞·ªùi L·∫° ∆†i - Karik ft. Orange", query: "karaoke ng∆∞·ªùi l·∫° ∆°i karik orange" },
      { title: "Karaoke S·∫ßu H·ªìng Gai - G5R Squad", query: "karaoke s·∫ßu h·ªìng gai g5r squad" },
      { title: "Karaoke ƒê·ª´ng Lo Anh ƒê·ª£i M√† - Mr. Siro", query: "karaoke ƒë·ª´ng lo anh ƒë·ª£i m√† mr siro" },
      { title: "Karaoke Waiting For You - Mono", query: "karaoke waiting for you mono" },
      { title: "Karaoke Mu·ªôn R·ªìi M√† Sao C√≤n - S∆°n T√πng M-TP", query: "karaoke mu·ªôn r·ªìi m√† sao c√≤n s∆°n t√πng" },
      { title: "Karaoke C√≥ Ch√†ng Trai Vi·∫øt L√™n C√¢y - Phan M·∫°nh Qu·ª≥nh", query: "karaoke c√≥ ch√†ng trai vi·∫øt l√™n c√¢y phan m·∫°nh qu·ª≥nh" },
      { title: "Karaoke L·∫°c Tr√¥i - S∆°n T√πng M-TP", query: "karaoke l·∫°c tr√¥i s∆°n t√πng" },
      { title: "Karaoke V√πng K√Ω ·ª®c - Chi D√¢n", query: "karaoke v√πng k√Ω ·ª©c chi d√¢n" },
      { title: "Karaoke H·ªç Y√™u Ai M·∫•t R·ªìi - Do√£n Hi·∫øu", query: "karaoke h·ªç y√™u ai m·∫•t r·ªìi do√£n hi·∫øu" },
      { title: "Karaoke Th∆∞∆°ng Em L√† ƒêi·ªÅu Anh Kh√¥ng Th·ªÉ Ng·ªù - Noo Ph∆∞·ªõc Th·ªãnh", query: "karaoke th∆∞∆°ng em l√† ƒëi·ªÅu anh kh√¥ng th·ªÉ ng·ªù noo ph∆∞·ªõc th·ªãnh" },
      { title: "Karaoke B√™n Tr√™n T·∫ßng L·∫ßu - TƒÉng Duy T√¢n", query: "karaoke b√™n tr√™n t·∫ßng l·∫ßu tƒÉng duy t√¢n" },
      { title: "Karaoke Hoa N·ªü Kh√¥ng M√†u - Ho√†i L√¢m", query: "karaoke hoa n·ªü kh√¥ng m√†u ho√†i l√¢m" },
      { title: "Karaoke C∆∞·ªõi Th√¥i - Masew, BRay", query: "karaoke c∆∞·ªõi th√¥i masew bray" },
      { title: "Karaoke Y√™u L√† C∆∞·ªõi - Ph√°t H·ªì", query: "karaoke y√™u l√† c∆∞·ªõi ph√°t h·ªì" }
    ];

    const searchInput = document.getElementById("search");
    const resultsList = document.getElementById("results");
    const status = document.getElementById("status");
    const modal = document.getElementById("modal");
    const modalFrame = document.getElementById("modal-frame");
    const modalPlaceholder = document.getElementById("modal-placeholder");
    const modalClose = document.getElementById("modal-close");
    const MIN_CHARS = 2;

    function setStatus(message) {
      status.textContent = message || "";
    }

    function showModal(message) {
      modalPlaceholder.textContent = message || "ƒêang chu·∫©n b·ªã video karaoke...";
      modalPlaceholder.style.display = "grid";
      modalFrame.style.display = "none";
      modalFrame.src = "";
      modal.classList.remove("hidden");
      document.body.classList.add("modal-open");
    }

    function playInModal(src, message) {
      if (message) {
        modalPlaceholder.textContent = message;
      }
      modalPlaceholder.style.display = "grid";
      modalFrame.style.display = "none";
      modalFrame.src = src;
    }

    function createItem(song) {
      const li = document.createElement("li");
      const button = document.createElement("button");
      button.type = "button";
      button.textContent = song.title;
      button.dataset.query = song.query;
      button.addEventListener("click", () => playSong(song.query, song.title));
      li.appendChild(button);
      return li;
    }

    async function playSong(query, title) {
      showModal(`ƒêang chu·∫©n b·ªã video cho: ${title}`);
      setStatus(`ƒêang t√¨m video: ${title}`);
      const fallback = `https://www.youtube.com/embed?listType=search&list=${encodeURIComponent(query)}&autoplay=1&rel=0&modestbranding=1&playsinline=1`;
      
      // Lu√¥n c√≥ fallback s·∫µn s√†ng
      let fallbackTimeout = setTimeout(() => {
        playInModal(fallback, "ƒêang t·∫£i danh s√°ch karaoke...");
        setStatus(`ƒêang ph√°t danh s√°ch karaoke: ${title}`);
      }, 5000); // Sau 5 gi√¢y n·∫øu ch∆∞a c√≥ k·∫øt qu·∫£, d√πng fallback
      
      try {
        const videoId = await fetchFirstVideoId(query);
        clearTimeout(fallbackTimeout);
        
        if (!videoId) {
          playInModal(fallback, "ƒêang ph√°t danh s√°ch karaoke ph√π h·ª£p...");
          setStatus(`ƒêang ph√°t danh s√°ch karaoke theo t·ª´ kh√≥a: ${title}`);
          return;
        }
        
        playInModal(
          `https://www.youtube-nocookie.com/embed/${videoId}?autoplay=1&rel=0&modestbranding=1&playsinline=1&enablejsapi=1`,
          "ƒêang t·∫£i video karaoke..."
        );
        setStatus(`ƒêang ph√°t: ${title}`);
      } catch (error) {
        clearTimeout(fallbackTimeout);
        playInModal(fallback, "ƒêang ph√°t danh s√°ch karaoke...");
        setStatus(`ƒêang ph√°t danh s√°ch karaoke: ${title}`);
        console.error('L·ªói khi t√¨m video:', error);
      }
    }

    function closeModal() {
      modal.classList.add("hidden");
      document.body.classList.remove("modal-open");
      modalPlaceholder.textContent = "ƒêang chu·∫©n b·ªã video...";
      modalPlaceholder.style.display = "grid";
      modalFrame.style.display = "none";
      modalFrame.src = "";
      setStatus("ƒê√£ ƒë√≥ng tr√¨nh ph√°t.");
    }

    modalFrame.addEventListener("load", () => {
      if (modal.classList.contains("hidden")) return;
      modalPlaceholder.style.display = "none";
      modalFrame.style.display = "block";
    });
    
    // X·ª≠ l√Ω l·ªói iframe tr√™n mobile
    modalFrame.addEventListener("error", () => {
      if (modal.classList.contains("hidden")) return;
      const currentSrc = modalFrame.src;
      if (currentSrc && currentSrc.includes('youtube')) {
        // Th·ª≠ fallback v·ªõi URL kh√°c
        const fallbackUrl = currentSrc.replace('youtube-nocookie.com', 'youtube.com');
        modalFrame.src = fallbackUrl;
        modalPlaceholder.textContent = "ƒêang th·ª≠ ph∆∞∆°ng √°n d·ª± ph√≤ng...";
      }
    });

    modalClose.addEventListener("click", closeModal);

    modal.addEventListener("click", (event) => {
      if (event.target === modal) {
        closeModal();
      }
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && !modal.classList.contains("hidden")) {
        closeModal();
      }
    });

    function showEmpty() {
      const li = document.createElement("li");
      li.className = "empty";
      li.textContent = "Kh√¥ng c√≥ k·∫øt qu·∫£.";
      return li;
    }

    // ============================================
    // C·∫§U H√åNH YOUTUBE API (T√ôY CH·ªåN)
    // ============================================
    // 
    // ‚ö†Ô∏è L∆ØU √ù QUAN TR·ªåNG:
    // - YouTube Data API c√≥ gi·ªõi h·∫°n: 10,000 units/ng√†y (mi·ªÖn ph√≠)
    // - M·ªói l·∫ßn search = 100 units ‚Üí ~100 l·∫ßn t√¨m ki·∫øm/ng√†y
    // - N·∫øu nhi·ªÅu ng∆∞·ªùi d√πng ‚Üí d·ªÖ h·∫øt quota ‚Üí c√≥ th·ªÉ b·ªã t√≠nh ph√≠
    // 
    // ‚úÖ GI·∫¢I PH√ÅP HI·ªÜN T·∫†I (KHUY·∫æN NGH·ªä):
    // - D√πng web scraping (kh√¥ng gi·ªõi h·∫°n quota, mi·ªÖn ph√≠)
    // - T·ª± ƒë·ªông fallback sang danh s√°ch ph√°t YouTube n·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c video
    // 
    // üîß N·∫æU MU·ªêN D√ôNG API:
    // 1. T·∫°o backend proxy (Node.js/Python/PHP) ƒë·ªÉ b·∫£o v·ªá API key
    // 2. Backend s·∫Ω g·ªçi YouTube API v√† tr·∫£ k·∫øt qu·∫£ v·ªÅ
    // 3. ƒê·∫∑t USE_YOUTUBE_API = true v√† cung c·∫•p API_PROXY_URL
    // 
    // üìù V√ç D·ª§ BACKEND PROXY (Node.js/Express):
    // app.get('/api/youtube-search', async (req, res) => {
    //   const query = req.query.q;
    //   const response = await fetch(
    //     `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${query}&key=YOUR_API_KEY&type=video&maxResults=1`
    //   );
    //   const data = await response.json();
    //   res.json(data);
    // });
    //
    const USE_YOUTUBE_API = false; // ƒê·∫∑t true n·∫øu c√≥ backend proxy
    const API_PROXY_URL = ''; // URL backend proxy (v√≠ d·ª•: 'https://your-backend.com/api/youtube-search')
    
    // H√†m t√¨m ki·∫øm b·∫±ng YouTube API (qua backend proxy)
    async function searchYouTubeAPI(query) {
      if (!API_PROXY_URL) return null;
      
      try {
        const response = await fetch(`${API_PROXY_URL}?q=${encodeURIComponent(query)}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error('API request failed');
        }
        
        const data = await response.json();
        if (data.items && data.items.length > 0) {
          return data.items[0].id.videoId;
        }
        return null;
      } catch (error) {
        console.log('YouTube API failed, falling back to scraping:', error);
        return null;
      }
    }
    
    // H√†m t√¨m ki·∫øm tr√™n YouTube (kh√¥ng d√πng API - web scraping qua proxy)
    async function searchYouTube(query) {
      if (!query || query.length < 2) {
        return null;
      }
      
      const searchQuery = encodeURIComponent(query);
      
      // T·∫°o AbortController v·ªõi timeout (d√†i h∆°n cho mobile)
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const timeout = isMobile ? 12000 : 6000; // TƒÉng timeout cho mobile
      
      const createFetchWithTimeout = (url, timeoutMs = timeout) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
        return fetch(url, { 
          signal: controller.signal,
          mode: 'cors',
          cache: 'no-cache'
        })
          .then(response => {
            clearTimeout(timeoutId);
            if (!response.ok) throw new Error('Network response was not ok');
            return response;
          })
          .catch(err => {
            clearTimeout(timeoutId);
            throw err;
          });
      };
      
      // Th·ª≠ nhi·ªÅu proxy c√πng l√∫c (∆∞u ti√™n proxy ·ªïn ƒë·ªãnh cho mobile)
      const youtubeUrl = `https://www.youtube.com/results?search_query=${searchQuery}`;
      const proxyPromises = [
        // Proxy 1: allorigins (·ªïn ƒë·ªãnh nh·∫•t)
        createFetchWithTimeout(`https://api.allorigins.win/get?url=${encodeURIComponent(youtubeUrl)}`)
          .then(r => r.json())
          .then(d => d.contents || '')
          .catch(() => ''),
        // Proxy 2: corsproxy (t·ªët cho mobile)
        createFetchWithTimeout(`https://corsproxy.io/?${encodeURIComponent(youtubeUrl)}`)
          .then(r => r.text())
          .catch(() => ''),
        // Proxy 3: codetabs
        createFetchWithTimeout(`https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(youtubeUrl)}`)
          .then(r => r.text())
          .catch(() => ''),
        // Proxy 4: thingproxy (backup)
        createFetchWithTimeout(`https://thingproxy.freeboard.io/fetch/${youtubeUrl}`)
          .then(r => r.text())
          .catch(() => '')
      ];
      
      try {
        let html = '';
        // Th·ª≠ Promise.race tr∆∞·ªõc (l·∫•y k·∫øt qu·∫£ nhanh nh·∫•t)
        try {
          html = await Promise.race(proxyPromises);
        } catch (raceError) {
          console.log('Promise.race failed, trying allSettled...');
        }
        
        // N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£, th·ª≠ t·∫•t c·∫£
        if (!html || html.trim() === '') {
          const settled = await Promise.allSettled(proxyPromises);
          for (const result of settled) {
            if (result.status === 'fulfilled' && result.value && result.value.trim() !== '') {
              html = result.value;
              console.log('Got HTML from fallback proxy');
              break;
            }
          }
        }
        
        if (!html || html.trim() === '') {
          console.log('No HTML content from proxies, trying RSS fallback...');
          // Fallback: Th·ª≠ RSS feed (ƒë∆°n gi·∫£n h∆°n, √≠t b·ªã ch·∫∑n h∆°n)
          try {
            const rssUrl = `https://www.youtube.com/feeds/videos.xml?search_query=${searchQuery}`;
            const rssResponse = await createFetchWithTimeout(rssUrl, timeout);
            if (rssResponse.ok) {
              const xmlText = await rssResponse.text();
              const parser = new DOMParser();
              const doc = parser.parseFromString(xmlText, "application/xml");
              const entry = doc.getElementsByTagName("entry")[0];
              if (entry) {
                const videoTag = entry.getElementsByTagName("yt:videoId")[0] || entry.getElementsByTagName("videoId")[0];
                if (videoTag && videoTag.textContent) {
                  console.log('Got videoId from RSS feed');
                  return videoTag.textContent;
                }
              }
            }
          } catch (rssError) {
            console.log('RSS fallback also failed:', rssError);
          }
          return null;
        }
        
        // Parse v·ªõi regex - t√¨m pattern videoRenderer
        const videoPattern = /"videoRenderer":\{[^}]*"videoId":"([^"]{11})"[^}]*"title":\{"runs":\[\{"text":"([^"]+)"\}[^}]*"ownerText":\{"runs":\[\{"text":"([^"]+)"\}/g;
        
        let match;
        const seenIds = new Set();
        match = videoPattern.exec(html);
        
        if (match && match[1]) {
          const videoId = match[1];
          if (!seenIds.has(videoId)) {
            seenIds.add(videoId);
            console.log('Got videoId from videoRenderer pattern');
            return videoId;
          }
        }
        
        // Fallback: pattern ƒë∆°n gi·∫£n h∆°n - t√¨m videoId ƒë·∫ßu ti√™n
        const videoIdRegex = /"videoId":"([^"]{11})"/g;
        const matches = [];
        let vidMatch;
        while ((vidMatch = videoIdRegex.exec(html)) !== null && matches.length < 5) {
          if (!seenIds.has(vidMatch[1])) {
            seenIds.add(vidMatch[1]);
            matches.push(vidMatch[1]);
          }
        }
        
        if (matches.length > 0) {
          console.log('Got videoId from simple pattern');
          return matches[0];
        }
        
        return null;
      } catch (error) {
        console.error('L·ªói t√¨m ki·∫øm YouTube:', error);
        return null;
      }
    }

    // ============================================
    // C√ÅC PH∆Ø∆†NG PH√ÅP L·∫§Y VIDEO YOUTUBE KH√îNG C·∫¶N API
    // ============================================
    //
    // 1. YouTube RSS Feed ‚≠ê (KHUY·∫æN NGH·ªä - ∆Øu ti√™n)
    //    - Mi·ªÖn ph√≠, kh√¥ng gi·ªõi h·∫°n
    //    - ·ªîn ƒë·ªãnh, √≠t b·ªã ch·∫∑n
    //    - Nhanh, ƒë∆°n gi·∫£n
    //    - URL: https://www.youtube.com/feeds/videos.xml?search_query=...
    //
    // 2. Web Scraping qua Proxy
    //    - Mi·ªÖn ph√≠, kh√¥ng gi·ªõi h·∫°n
    //    - C√≥ th·ªÉ b·ªã ch·∫∑n n·∫øu YouTube thay ƒë·ªïi c·∫•u tr√∫c
    //    - C·∫ßn nhi·ªÅu proxy fallback
    //
    // 3. Extract t·ª´ YouTube URL
    //    - N·∫øu ng∆∞·ªùi d√πng paste link YouTube
    //    - H·ªó tr·ª£: youtube.com/watch?v=, youtu.be/, youtube.com/embed/
    //
    // 4. YouTube Search Embed (Fallback cu·ªëi)
    //    - Lu√¥n ho·∫°t ƒë·ªông, kh√¥ng c·∫ßn videoId
    //    - Hi·ªÉn th·ªã danh s√°ch ph√°t t√¨m ki·∫øm
    //    - URL: youtube.com/embed?listType=search&list=...
    //
    // 5. YouTube oEmbed API
    //    - Mi·ªÖn ph√≠ nh∆∞ng c·∫ßn videoId tr∆∞·ªõc
    //    - Kh√¥ng d√πng ƒë∆∞·ª£c ƒë·ªÉ search
    //
    
    // Ph∆∞∆°ng ph√°p 1: YouTube RSS Feed (mi·ªÖn ph√≠, ·ªïn ƒë·ªãnh, ∆∞u ti√™n)
    async function searchYouTubeRSS(query) {
      try {
        const rssUrl = `https://www.youtube.com/feeds/videos.xml?search_query=${encodeURIComponent(query)}`;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const timeout = isMobile ? 10000 : 5000;
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(rssUrl, { 
          signal: controller.signal,
          mode: 'cors'
        });
        clearTimeout(timeoutId);
        
        if (!response.ok) return null;
        
        const xmlText = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(xmlText, "application/xml");
        const entry = doc.getElementsByTagName("entry")[0];
        
        if (entry) {
          const videoTag = entry.getElementsByTagName("yt:videoId")[0] || entry.getElementsByTagName("videoId")[0];
          if (videoTag && videoTag.textContent) {
            console.log('Got videoId from RSS feed');
            return videoTag.textContent;
          }
        }
        return null;
      } catch (error) {
        console.log('RSS feed failed:', error);
        return null;
      }
    }
    
    // Ph∆∞∆°ng ph√°p 3: Extract videoId t·ª´ YouTube URL (n·∫øu ng∆∞·ªùi d√πng paste link)
    function extractVideoIdFromUrl(text) {
      const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
        /youtube\.com\/.*[?&]v=([a-zA-Z0-9_-]{11})/
      ];
      
      for (const pattern of patterns) {
        const match = text.match(pattern);
        if (match && match[1]) {
          console.log('Extracted videoId from URL');
          return match[1];
        }
      }
      return null;
    }
    
    // Ph∆∞∆°ng ph√°p 4: YouTube Search Embed (lu√¥n ho·∫°t ƒë·ªông, kh√¥ng c·∫ßn videoId)
    // ƒê√£ ƒë∆∞·ª£c d√πng l√†m fallback trong playSong()
    
    async function fetchFirstVideoId(rawQuery) {
      const keyword = rawQuery.toLowerCase().includes("karaoke")
        ? rawQuery
        : `${rawQuery} karaoke`;
      
      // Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng paste YouTube URL
      const videoIdFromUrl = extractVideoIdFromUrl(rawQuery);
      if (videoIdFromUrl) {
        return videoIdFromUrl;
      }
      
      // N·∫øu b·∫≠t API mode, th·ª≠ API tr∆∞·ªõc
      if (USE_YOUTUBE_API) {
        const apiResult = await searchYouTubeAPI(keyword);
        if (apiResult) {
          console.log('Got videoId from YouTube API');
          return apiResult;
        }
        console.log('API failed, trying other methods...');
      }
      
      // Ph∆∞∆°ng ph√°p 1: RSS Feed (nhanh, ·ªïn ƒë·ªãnh, √≠t b·ªã ch·∫∑n)
      const rssResult = await searchYouTubeRSS(keyword);
      if (rssResult) {
        return rssResult;
      }
      
      // Ph∆∞∆°ng ph√°p 2: Web Scraping qua proxy (n·∫øu RSS th·∫•t b·∫°i)
      const scrapingResult = await searchYouTube(keyword);
      if (scrapingResult) {
        return scrapingResult;
      }
      
      // N·∫øu t·∫•t c·∫£ ƒë·ªÅu th·∫•t b·∫°i, return null ‚Üí s·∫Ω d√πng search embed fallback
      return null;
    }

    searchInput.addEventListener("input", () => {
      const keyword = searchInput.value.trim().toLowerCase();
      resultsList.innerHTML = "";

      if (keyword.length < MIN_CHARS) {
        return;
      }

      const filtered = songs.filter((song) =>
        song.title.toLowerCase().includes(keyword)
      );

      if (!filtered.length) {
        resultsList.appendChild(showEmpty());
        return;
      }

      filtered.forEach((song) => resultsList.appendChild(createItem(song)));
    });
  </script>
</body>
</html>
