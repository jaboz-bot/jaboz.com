<!DOCTYPE html>
<html>
<head>
    <title>Basic Snake HTML Game</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            /* NgƒÉn cu·ªôn trang tr√™n mobile khi ch·∫°m */
            touch-action: none; 
        }

        body {
            background: black;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            border: 1px solid white;
            /* Thi·∫øt l·∫≠p k√≠ch th∆∞·ªõc canvas t·ªëi ƒëa cho mobile */
            max-width: 90vh; 
            max-height: 90vh;
        }
    </style>
</head>
<body>
    <canvas width="400" height="400" id="game"></canvas>
    <script>
        var canvas = document.getElementById('game');
        var context = canvas.getContext('2d');

        // the canvas width & height, snake x & y, and the apple x & y, all need to be a multiples of the grid size in order for collision detection to work
        // (e.g. 16 * 25 = 400)
        var grid = 16;
        var count = 0;

        var snake = {
            x: 160,
            y: 160,

            // snake velocity. moves one grid length every frame in either the x or y direction
            dx: grid,
            dy: 0,

            // keep track of all grids the snake body occupies
            cells: [],

            // length of the snake. grows when eating an apple
            maxCells: 4
        };
        var apple = {
            x: 320,
            y: 320
        };

        // get random whole numbers in a specific range
        // @see https://stackoverflow.com/a/1527820/2124254
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }

        // H√†m x·ª≠ l√Ω vi·ªác thay ƒë·ªïi h∆∞·ªõng c·ªßa r·∫Øn, ngƒÉn r·∫Øn ƒëi ng∆∞·ª£c l·∫°i ch√≠nh n√≥
        function setSnakeDirection(newDx, newDy) {
            if ((newDx !== 0 && snake.dx === 0) || (newDy !== 0 && snake.dy === 0)) {
                if (newDx !== 0 && snake.dx === 0) { // ƒêang ƒëi l√™n/xu·ªëng, chuy·ªÉn sang tr√°i/ph·∫£i
                    snake.dx = newDx;
                    snake.dy = 0;
                } else if (newDy !== 0 && snake.dy === 0) { // ƒêang ƒëi tr√°i/ph·∫£i, chuy·ªÉn sang l√™n/xu·ªëng
                    snake.dy = newDy;
                    snake.dx = 0;
                }
            }
        }
        
        // game loop
        function loop() {
            requestAnimationFrame(loop);

            // slow game loop to 15 fps instead of 60 (60/15 = 4)
            if (++count < 4) {
                return;
            }

            count = 0;
            context.clearRect(0, 0, canvas.width, canvas.height);

            // move snake by it's velocity
            snake.x += snake.dx;
            snake.y += snake.dy;

            // wrap snake position horizontally on edge of screen
            if (snake.x < 0) {
                snake.x = canvas.width - grid;
            } else if (snake.x >= canvas.width) {
                snake.x = 0;
            }

            // wrap snake position vertically on edge of screen
            if (snake.y < 0) {
                snake.y = canvas.height - grid;
            } else if (snake.y >= canvas.height) {
                snake.y = 0;
            }

            // keep track of where snake has been. front of the array is always the head
            snake.cells.unshift({
                x: snake.x,
                y: snake.y
            });

            // remove cells as we move away from them
            if (snake.cells.length > snake.maxCells) {
                snake.cells.pop();
            }

            // draw apple
            context.fillStyle = 'red';
            context.fillRect(apple.x, apple.y, grid - 1, grid - 1);

            // draw snake one cell at a time
            context.fillStyle = 'green';
            snake.cells.forEach(function(cell, index) {

                // drawing 1 px smaller than the grid creates a grid effect in the snake body so you can see how long it is
                context.fillRect(cell.x, cell.y, grid - 1, grid - 1);

                // snake ate apple
                if (cell.x === apple.x && cell.y === apple.y) {
                    snake.maxCells++;

                    // canvas is 400x400 which is 25x25 grids
                    // ƒê·∫£m b·∫£o t√°o kh√¥ng sinh ra tr√™n th√¢n r·∫Øn
                    var newAppleX, newAppleY;
                    do {
                        newAppleX = getRandomInt(0, 25) * grid;
                        newAppleY = getRandomInt(0, 25) * grid;
                    } while (snake.cells.some(c => c.x === newAppleX && c.y === newAppleY)); 

                    apple.x = newAppleX;
                    apple.y = newAppleY;
                }

                // check collision with all cells after this one (modified bubble sort)
                for (var i = index + 1; i < snake.cells.length; i++) {

                    // snake occupies same space as a body part. reset game
                    if (cell.x === snake.cells[i].x && cell.y === snake.cells[i].y) {
                        snake.x = 160;
                        snake.y = 160;
                        snake.cells = [];
                        snake.maxCells = 4;
                        snake.dx = grid;
                        snake.dy = 0;

                        apple.x = getRandomInt(0, 25) * grid;
                        apple.y = getRandomInt(0, 25) * grid;
                    }
                }
            });
        }

        // ----------------------------------------------------------------
        // --- X·ª≠ l√Ω ƒêi·ªÅu khi·ªÉn cho M√°y t√≠nh (Ph√≠m) ‚å®Ô∏è ---
        // ----------------------------------------------------------------
        document.addEventListener('keydown', function(e) {
            // left arrow key (37)
            if (e.which === 37) {
                setSnakeDirection(-grid, 0);
            }
            // up arrow key (38)
            else if (e.which === 38) {
                setSnakeDirection(0, -grid);
            }
            // right arrow key (39)
            else if (e.which === 39) {
                setSnakeDirection(grid, 0);
            }
            // down arrow key (40)
            else if (e.which === 40) {
                setSnakeDirection(0, grid);
            }
        });

        // ----------------------------------------------------------------
        // --- X·ª≠ l√Ω ƒêi·ªÅu khi·ªÉn cho ƒêi·ªán tho·∫°i (C·∫£m ·ª©ng/Vu·ªët) üì± ---
        // ----------------------------------------------------------------
        var touchStartX = 0;
        var touchStartY = 0;
        var touchEndX = 0;
        var touchEndY = 0;
        var minSwipeDistance = 20; // Kho·∫£ng c√°ch t·ªëi thi·ªÉu ƒë·ªÉ ƒë∆∞·ª£c coi l√† m·ªôt l·∫ßn vu·ªët

        canvas.addEventListener('touchstart', function(event) {
            // L·∫•y v·ªã tr√≠ b·∫Øt ƒë·∫ßu ch·∫°m (ch·ªâ l·∫•y ng√≥n tay ƒë·∫ßu ti√™n)
            touchStartX = event.changedTouches[0].screenX;
            touchStartY = event.changedTouches[0].screenY;
            // NgƒÉn cu·ªôn trang tr√™n tr√¨nh duy·ªát di ƒë·ªông
            event.preventDefault(); 
        }, { passive: false }); // {passive: false} quan tr·ªçng ƒë·ªÉ ngƒÉn cu·ªôn

        canvas.addEventListener('touchend', function(event) {
            // L·∫•y v·ªã tr√≠ k·∫øt th√∫c ch·∫°m (ch·ªâ l·∫•y ng√≥n tay ƒë·∫ßu ti√™n)
            touchEndX = event.changedTouches[0].screenX;
            touchEndY = event.changedTouches[0].screenY;
            handleGesture();
            // NgƒÉn cu·ªôn trang
            event.preventDefault(); 
        }, { passive: false });

        function handleGesture() {
            var dx = touchEndX - touchStartX;
            var dy = touchEndY - touchStartY;

            // Ki·ªÉm tra xem ƒë√≥ c√≥ ph·∫£i l√† m·ªôt c·ª≠ ch·ªâ vu·ªët ƒë·ªß d√†i hay kh√¥ng
            if (Math.abs(dx) > Math.abs(dy)) { // Vu·ªët ngang (tr√°i ho·∫∑c ph·∫£i)
                if (Math.abs(dx) > minSwipeDistance) {
                    if (dx > 0) { // Vu·ªët sang ph·∫£i
                        setSnakeDirection(grid, 0);
                    } else { // Vu·ªët sang tr√°i
                        setSnakeDirection(-grid, 0);
                    }
                }
            } else { // Vu·ªët d·ªçc (l√™n ho·∫∑c xu·ªëng)
                if (Math.abs(dy) > minSwipeDistance) {
                    if (dy > 0) { // Vu·ªët xu·ªëng
                        setSnakeDirection(0, grid);
                    } else { // Vu·ªët l√™n
                        setSnakeDirection(0, -grid);
                    }
                }
            }
        }

        // start the game
        requestAnimationFrame(loop);
    </script>
</body>
</html>
