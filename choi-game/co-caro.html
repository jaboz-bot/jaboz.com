<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cờ Caro Responsive</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
</head>
<body>
    <div class="app">
        <div class="app-container">
            <h2 class="title">Cờ Caro (Gomoku)</h2>
        </div>
        <div class="board">
            <div class="status" id="status">Người chơi: X</div>
            <div class="list-button">
                <button class="button" id="restart-btn">
                    <i class="bi bi-arrow-counterclockwise"></i> Chơi lại
                </button>
                <button class="button" id="single-player-toggle">&#x1F477; Máy</button>
                <button class="button" id="dimension-button">10x10</button>
            </div>
        </div>
        <div id="board" class="game"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const dimensionButton = document.getElementById('dimension-button');
            const statusElement = document.getElementById('status');
            const restartButton = document.getElementById('restart-btn');
            const singlePlayerToggle = document.getElementById('single-player-toggle');
            const boardElement = document.getElementById('board');
            
            // --- Cấu hình trò chơi ---
            const dimensions = [10, 12, 16, 20];
            let dimensionIndex = 0;
            let dimension = dimensions[dimensionIndex]; 
            
            let singlePlayerMode = false;
            let squares; // Khởi tạo trong restartGame
            let xIsNext; // Người chơi hiện tại (true = X, false = O)
            let theWinner = null;
            let winningLine = [];

            // Cập nhật text nút kích thước ban đầu
            dimensionButton.textContent = `${dimension}x${dimension}`;

            // --- Xử lý sự kiện ---
            dimensionButton.addEventListener('click', function () {
                dimensionIndex = (dimensionIndex + 1) % dimensions.length;
                dimension = dimensions[dimensionIndex];
                dimensionButton.textContent = `${dimension}x${dimension}`;
                restartGame();
            });

            restartButton.addEventListener('click', restartGame);

            singlePlayerToggle.addEventListener('click', function () {
                toggleSinglePlayerMode();
                restartGame();
            });

            // --- Logic Trò chơi ---

            function handleClick(row, col) {
                // Thoát nếu đã có người thắng hoặc ô đã được đánh
                if (theWinner || squares[row][col]) {
                    return;
                }

                // Tạo bản sao của mảng squares (quan trọng!)
                const newSquares = squares.map(arr => [...arr]); 
                newSquares[row][col] = xIsNext ? 'X' : 'O';
                squares = newSquares;
                xIsNext = !xIsNext; // Chuyển lượt

                const winner = calculateWinner(newSquares, row, col);
                if (winner) {
                    theWinner = winner;
                    winningLine = findWinningLine(newSquares, row, col, winner);
                }

                renderBoard();
                updateStatus();

                // Nếu là chế độ chơi đơn và chưa có người thắng và đến lượt máy (O)
                if (singlePlayerMode && !theWinner && !xIsNext) {
                    // Dùng setTimeout để tạo độ trễ, giúp trò chơi trông tự nhiên hơn
                    setTimeout(makeComputerMove, 500); 
                }
            }

            function calculateWinner(currentSquares, row, col) {
                const currentPlayer = currentSquares[row][col];
                if (!currentPlayer) return null;
                const winCondition = 5;

                // Hàm kiểm tra theo 4 hướng (ngang, dọc, 2 chéo)
                function checkDirection(dRow, dCol) {
                    let count = 1;
                    let r, c;

                    // Kiểm tra một phía
                    r = row + dRow;
                    c = col + dCol;
                    while (r >= 0 && r < dimension && c >= 0 && c < dimension && currentSquares[r][c] === currentPlayer) {
                        count++;
                        r += dRow;
                        c += dCol;
                    }

                    // Kiểm tra phía ngược lại
                    r = row - dRow;
                    c = col - dCol;
                    while (r >= 0 && r < dimension && c >= 0 && c < dimension && currentSquares[r][c] === currentPlayer) {
                        count++;
                        r -= dRow;
                        c -= dCol;
                    }
                    return count;
                }

                // 4 hướng: [dRow, dCol]
                const directions = [
                    [0, 1],   // Ngang
                    [1, 0],   // Dọc
                    [1, 1],   // Chéo chính
                    [1, -1]   // Chéo phụ
                ];

                for (const [dRow, dCol] of directions) {
                    if (checkDirection(dRow, dCol) >= winCondition) {
                        return currentPlayer;
                    }
                }
                return null;
            }

            function findWinningLine(currentSquares, row, col, winner) {
                const currentPlayer = currentSquares[row][col];
                const winCondition = 5;

                // Hàm tìm đường thắng theo một hướng
                function findLine(dRow, dCol) {
                    const line = [];
                    let r, c;

                    // Lùi về điểm bắt đầu của chuỗi 5
                    let startR = row, startC = col;
                    r = row - dRow;
                    c = col - dCol;
                    while (r >= 0 && r < dimension && c >= 0 && c < dimension && currentSquares[r][c] === currentPlayer) {
                        startR = r; startC = c;
                        r -= dRow; c -= dCol;
                    }

                    // Tiến từ điểm bắt đầu để lấy 5 ô
                    for (let i = 0; i < dimension; i++) {
                        r = startR + i * dRow;
                        c = startC + i * dCol;
                        if (r < 0 || r >= dimension || c < 0 || c >= dimension || currentSquares[r][c] !== currentPlayer) {
                            break;
                        }
                        line.push([r, c]);
                        if (line.length >= winCondition) {
                            // Kiểm tra xem 5 ô cuối cùng có đủ 5 ô liên tiếp không
                            if (line.slice(-winCondition).length === winCondition) {
                                return line.slice(-winCondition);
                            }
                        }
                    }
                    return [];
                }

                // 4 hướng: [dRow, dCol]
                const directions = [
                    [0, 1],   // Ngang
                    [1, 0],   // Dọc
                    [1, 1],   // Chéo chính
                    [1, -1]   // Chéo phụ
                ];

                for (const [dRow, dCol] of directions) {
                    const line = findLine(dRow, dCol);
                    if (line.length >= winCondition) {
                        return line;
                    }
                }
                return [];
            }


            function renderBoard() {
                boardElement.innerHTML = '';
                // Thêm CSS class dựa trên kích thước
                boardElement.className = `game board-${dimension}x${dimension}`; 

                for (let row = 0; row < dimension; row++) {
                    const rowElement = document.createElement('div');
                    rowElement.className = 'board-row';

                    for (let col = 0; col < dimension; col++) {
                        const value = squares[row][col];
                        // Kiểm tra ô có nằm trong đường thắng không
                        const isWinningSquare = winningLine.some(([winRow, winCol]) => winRow === row && winCol === col);

                        const squareButton = document.createElement('button');
                        squareButton.className = 'square';
                        // Dùng màu vàng sáng cho ô thắng
                        squareButton.style.backgroundColor = isWinningSquare ? '#ffeb3b' : 'white'; 
                        
                        // Đặt data-value để CSS xử lý màu chữ (X=blue, O=red)
                        if (value) {
                            squareButton.setAttribute('data-value', value);
                        }
                        // Giữ lại font bold cho ô thắng
                        if (isWinningSquare) {
                            squareButton.style.fontWeight = 'bold';
                        }
                        
                        squareButton.textContent = value;
                        squareButton.addEventListener('click', () => {
                            // Cho phép người chơi X click khi chơi đơn (luôn là người đi trước)
                            if (!singlePlayerMode || (singlePlayerMode && xIsNext)) { 
                                handleClick(row, col);
                            }
                        });

                        rowElement.appendChild(squareButton);
                    }
                    boardElement.appendChild(rowElement);
                }
            }

            function updateStatus() {
                if (theWinner) {
                    statusElement.textContent = `🎉 ${theWinner} đã chiến thắng! 🎉`;
                    statusElement.style.color = theWinner === 'X' ? 'blue' : 'red';
                } else if (squares.flat().every(val => val !== null)) { // Kiểm tra hòa
                    statusElement.textContent = 'Hòa cờ!';
                    statusElement.style.color = '#333';
                } else {
                    statusElement.textContent = `Người chơi: ${xIsNext ? 'X' : 'O'}`;
                    statusElement.style.color = xIsNext ? 'blue' : 'red';
                }
            }

            function restartGame() {
                // KHẮC PHỤC: Sử dụng Array.from để tạo mảng con độc lập cho mỗi hàng
                squares = Array.from({ length: dimension }, () => Array(dimension).fill(null));
                
                xIsNext = Math.random() < 0.5; // Chọn ngẫu nhiên người đi trước
                theWinner = null;
                winningLine = [];
                updateStatus();
                renderBoard();
                
                // Nếu chế độ chơi đơn đã bật và đến lượt máy (O), máy đi nước đầu tiên
                if (singlePlayerMode && !xIsNext) {
                    setTimeout(makeComputerMove, 500); 
                }
            }

            function toggleSinglePlayerMode() {
                singlePlayerMode = !singlePlayerMode;
                if (singlePlayerMode) {
                    singlePlayerToggle.innerHTML = '&#x1F4BB; Máy'; // Biểu tượng máy tính
                    singlePlayerToggle.style.backgroundColor = '#28a745';
                } else {
                    singlePlayerToggle.innerHTML = '&#x1F477; 2 Người'; // Biểu tượng 2 người
                    singlePlayerToggle.style.backgroundColor = '#007bff';
                }
            }

            // --- Logic AI (Cơ bản) ---
            function makeComputerMove() {
                if (!singlePlayerMode || theWinner) return;

                const availableMoves = [];
                const humanPlayer = 'X';
                const computerPlayer = 'O';

                squares.forEach((row, rowIndex) => {
                    row.forEach((col, colIndex) => {
                        if (col === null) {
                            availableMoves.push([rowIndex, colIndex]);
                        }
                    });
                });

                if (availableMoves.length === 0) return;

                // 1. Chiến thắng: Kiểm tra xem máy có thể thắng ngay không
                for (const [row, col] of availableMoves) {
                    const tempSquares = squares.map(arr => [...arr]);
                    tempSquares[row][col] = computerPlayer;
                    if (calculateWinner(tempSquares, row, col) === computerPlayer) {
                        handleClick(row, col);
                        return;
                    }
                }

                // 2. Phòng thủ: Kiểm tra xem người chơi có thể thắng ngay không
                for (const [row, col] of availableMoves) {
                    const tempSquares = squares.map(arr => [...arr]);
                    tempSquares[row][col] = humanPlayer;
                    if (calculateWinner(tempSquares, row, col) === humanPlayer) {
                        handleClick(row, col);
                        return;
                    }
                }

                // 3. Đánh ở giữa nếu còn trống (Ưu tiên cho bàn cờ nhỏ)
                const center = Math.floor(dimension / 2);
                if (squares[center][center] === null) {
                    handleClick(center, center);
                    return;
                }

                // 4. Di chuyển ngẫu nhiên
                const randomIndex = Math.floor(Math.random() * availableMoves.length);
                const [row, col] = availableMoves[randomIndex];
                handleClick(row, col);
            }

            // Khởi tạo trò chơi lần đầu
            restartGame(); 
            toggleSinglePlayerMode(); // Đặt trạng thái ban đầu là 2 Người
        });
    </script>
</body>
</html>
